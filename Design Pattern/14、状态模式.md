## 状态模式

状态模式：**允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类**

状态模式的关键是**区分事物内部的状态**，事物内部状态的改变往往会带来事物的**行为改变**

### 电灯开关示例

想象现在有一个场景：家里的电灯有一个开关，当电灯是开启状态时，按下开关将切换到关闭状态，再按一次开关将切换回开启状态。这是最普通的电灯开关场景，同一个开关按钮，**在不同状态下，表现出来的行为是不同的**

![Alt text](./imgs/14-01.png)

下面先编写这个例子：

```js
class Light {
    constructor() {
        this.state = 'off';
        this.button = null;
    }
    init() {
        const button = document.createElement('button');
        button.innerHTML = '开关';
        this.button = document.body.appendChild(button);

        this.button.onclick = () => this.buttonWasPressed();
    }
    buttonWasPressed() {
        if (this.state === 'off') {
            console.log('开灯');
            this.state = 'on';
        } else if (this.state === 'on') {
            console.log('关灯');
            this.state = 'off';
        }
    }
}

const light = new Light();
light.init();
```

可以看到，我们成功编写了一个电灯的状态机，这个状态机逻辑既简单又缜密

实际上这种代码我们在平时开发中编写过无数次，如点击 button 后切换元素的 class

但是遗憾的是，电灯并不一定像我们切换 class 一样只有开关 2 种状态，可能有一种电灯的状态切换是：弱光 => 强光 => 关闭

现在必须改造上面的 buttonWasPressed 方法：

```js
buttonWasPressed() {
    if (this.state === 'off') {
        console.log('弱光');
        this.state = 'weakLight';
    } else if (this.state === 'weakLight') {
        console.log('强光');
        this.state = 'strongLight';
    } else if (this.state === 'strongLight') {
        console.log('关灯');
        this.state = 'off';
    }
}
```
上述代码存在的问题是显而易见的：

- buttonWasPressed 违背开放-封闭原则，每次新增或修改状态，都需要改动 buttonWasPressed 代码，buttonWasPressed 成了一个不稳定方法

- 与状态相关的行为，都封装在了 buttonWasPressed 中，未来需求新增了更多的状态：超强光、紫外线光等，那么 buttonWasPressed 将无限膨胀，并且实际开发中每种状态执行的逻辑更为复杂，不只是像现在这样 console.log 打印而已，这样 buttonWasPressed 会非常庞大

- 状态切换不明显，仅仅是使用如 this.state = 'weakLight' 变量赋值，在实际开发中很容易不小心漏掉，也没有办法一目了然明白点灯有多少种状态。并且当状态非常多时，某一次切换过程就需要去庞大的 buttonWasPressed 中去寻找

#### 状态模式重构点灯代码

通常谈起封装，一般会是封装对象的行为，如上述代码在正常封装下，可能是这样：

```js
const behaviour = {
    off: light => {
        console.log('弱光');
        light.state = 'weakLight';
    },
    weakLight: light => {
        console.log('强光');
        light.state = 'strongLight';
    },
    strongLight: light => {
        console.log('关灯');
        light.state = 'off';
    },
}

buttonWasPressed() {
    behaviour[this.state](this);
}
```

但是状态模式相反，状态模式的关键是把**事物的每种状态封装成单独的类，跟此状态有关的行为都被封装在这个类的内部**

在按下 button 时，只需要在上下文中，把请求委托给当前状态对象，该状态对象负责渲染自身的行为

![Alt text](./imgs/14-02.png)

同时，我们也可以把状态切换规则分布在状态类中，从而消除原本大量的 if else 分支

![Alt text](./imgs/14-03.png)

下面重构代码，先定义 3 个状态类：

```js
class OffLightState {
    constructor(light) {
        this.light = light;
    }
    buttonWasPressed() {
        console.log('弱光');
        this.light.setState(this.light.weakLightState);
    }
}

class WeakLightState {
    constructor(light) {
        this.light = light;
    }
    buttonWasPressed() {
        console.log('强光');
        this.light.setState(this.light.strongLightState);
    }
}

class StrongLightState {
    constructor(light) {
        this.light = light;
    }
    buttonWasPressed() {
        console.log('关灯');
        this.light.setState(this.light.offLightState);
    }
}
```

接着重构 Light，类内部保存着所有状态，并且在 button 点击后不再做任何实质性操作，而是将请求委托给当前的状态对象去执行：

```js
class Light {
    constructor() {
        this.offLightState = new OffLightState(this);
        this.weakLightState = new WeakLightState(this);
        this.strongLightState = new StrongLightState(this);
        this.button = null;
    }
    init() {
        const button = document.createElement('button');
        button.innerHTML = '开关';
        this.button = document.body.appendChild(button);

        this.currState = this.offLightState; // 设置当前状态
        this.button.onclick = () => this.currState.buttonWasPressed();
    }
    setState(state) {
        this.currState = state;
    }
}
const light = new Light();
light.init();
```

通过状态模式重构后的好处很明显：

- 每一种状态和对应的行为之间的关系局部化

- 行为封装在各自对应的状态类，便于阅读和管理

- 新增状态只需要添加新状态类，再稍改现有代码即可

如现在需要状态切换过程为：弱光 => 强光 => 超强光 => 关闭：

```js
// 定义超强光类
class SuperStrongLightState {
    constructor(light) {
        this.light = light;
    }
    buttonWasPressed() {
        console.log('关灯');
        this.light.setState(this.light.offLightState);
    }
}

// 调整强光类
class StrongLightState {
    constructor(light) {
        this.light = light;
    }
    buttonWasPressed() {
        console.log('超强光');
        this.light.setState(this.light.superStrongLightState);
    }
}

// 补充 constructor
class Light {
    constructor() {
        this.offLightState = new OffLightState(this);
        this.weakLightState = new WeakLightState(this);
        this.strongLightState = new StrongLightState(this);
        this.superStrongLightState = new SuperStrongLightState(this); // 新增
        this.button = null;
    }
    ...
}
```
### 抽象类与缺少抽象类的变通

可以看到，在状态类中将会定义一些共同的行为方法，在这个例子中 ，无论定义多少状态类，都必须实现 buttonWasPressed 这个方法

通常在静态类型语言中，所有状态类都会继承自一个抽象类，这样就可以保证子状态类实现了必须实现的方法，下面我们用 typescript 来简单模拟：

```js
abstract class State {
    light: Light;
    constructor(light) {
        this.light = light;
    }
    abstract buttonWasPressed(): void;
}

class OffLightState extends State {
    buttonWasPressed() {
        console.log('弱光');
        this.light.setState(this.light.weakLightState);
    }
}

class WeakLightState extends State {
    buttonWasPressed() {
        console.log('强光');
        this.light.setState(this.light.strongLightState);
    }
}

class StrongLightState extends State {
    buttonWasPressed() {
        console.log('关灯');
        this.light.setState(this.light.offLightState);
    }
}

class Light {
    offLightState: OffLightState;
    weakLightState: WeakLightState;
    strongLightState: StrongLightState;
    button: HTMLButtonElement = null;
    currState: State = null;
    constructor() {
        this.offLightState = new OffLightState(this);
        this.weakLightState = new WeakLightState(this);
        this.strongLightState = new StrongLightState(this);
    }
    init() {
        const button = document.createElement('button');
        button.innerHTML = '开关';
        this.button = document.body.appendChild(button);

        this.currState = this.offLightState; // 设置当前状态
        this.button.onclick = () => this.currState.buttonWasPressed();
    }
    setState(state: State) {
        this.currState = state;
    }
}
```

遗憾的是，在 JavaScript 并没有抽象类也没有接口，在这其他章节也有提起过

解决方案是同“模板方法模式”的做法，模拟一个抽象父类，为未实现具体方法的子类在使用时直接抛出错误：

```js
class State {
    constructor(light) {
        this.light = light;
    }
    buttonWasPressed() {
        throw new Error('父类的 buttonWasPressed 方法必须被重写');
    }
}
class OffLightState extends State {
    // 子类没有实现 buttonWasPressed，调用时将抛出错误
    buttonWasPressed() {
        console.log('弱光');
        this.light.setState(this.light.weakLightState);
    }
}
```

### 文件上传示例

电灯示例是相对简单的例子，状态总是 A => B => C => A 这样循环，即使不用状态模式，常规的逻辑编写也不至于代码结构缭乱，因为状态总是有规律的

实际上在项目开发中往往是比较复杂的，例如文件上传的场景，可能充斥着有扫描、正在上传、暂停、上传成功、上传失败等等的状态，在上传中和暂停状态下的行为表现也是不同的

下面以文件上传为例

![Alt text](./imgs/14-04.png)

如图所示，控制文件上传一共 2 个按钮，第一个按钮用于暂停和恢复上传，第二个按钮用于删除文件

按钮与状态息息相关，状态有：扫描、正在上传、暂停、上传完成、上传失败

在不同的状态下，点击这 2 个按钮会有不同的行为：

- 扫描状态，2 个按钮都是禁用状态（不能暂停也不能删除），只能等待扫描结束。扫描完成后判断文件是否已在服务器，是则切换为“上传完成”状态，若文件大小超额或文件损坏，则切换为“上传失败”，其余切换为“上传中”

- 上传中可以点击第一个按钮暂停和恢复上传

- 只有“暂停”、“上传完成”、“上传失败” 才能点击第二个按钮删除文件

#### 准备工作

在实现代码前，先模拟一个上传插件，这里只做打印操作

假设全局环境下有一个上传的插件对象 plugin：

```js
const plugin = {
    sign() {
        console.log('开始文件扫描');
    },
    pause() {
        console.log('暂停文件上传');
    },
    uploading() {
        console.log('开始文件上传');
    },
    del() {
        console.log('删除文件上传');
    },
    done() {
        console.log('文件上传完成');
    },
}
```

#### 开始实现

首先定义 Upload 类型：

```js
class Upload {
    constructor(fileName) {
        this.plugin = plugin;
        this.fileName = fileName;
        this.dom = null;
        this.button_1 = null;
        this.button_2 = null;
        this.state = 'sign'; // 初始状态
    }
}

```

Upload 有一个初始化 init 方法，负责挂载节点，绑定事件：

```js
class Upload {
    ...
    init() {
        this.dom = document.createElement('div');
        this.dom.innerHTML =
            `<span>文件名称: ${this.fileName}</span>
            <button>扫描中</button>
            <button>删除</button>`;
        document.body.appendChild(this.dom);
        const buttons = this.dom.querySelectorAll('button');
        this.button_1 = buttons[0];
        this.button_2 = buttons[1];

        this.bindEvent();
    }
    ...
}
```

bindEvent 给按钮绑定点击事件，点击时根据状态做不同的变通：

```js
class Upload {
    ...
    bindEvent() {
        this.button_1.onclick = () => {
            if (this.state === 'sign') { // 扫描中，操作无效
                console.log('扫描中，点击无效...');
            } else if (this.state === 'uploading') { // 上传中 => 暂停
                this.pause();
            } else if (this.state === 'pause') { // 暂停 => 上传中
                this.uploading();
            } else if (this.state === 'done') { // 上传完成，操作无效
                console.log('文件已完成上传, 点击无效');
            } else if (this.state === 'error') { // 上传失败，操作无效
                console.log('文件上传失败, 点击无效');
            }
        }
        this.button_2.onclick = () => {
            if (this.state === 'done' || this.state === 'error' || this.state === 'pause') {
                // 上传完成、上传失败和暂停状态下可以删除
                this.del();
            } else if (this.state === 'sign') { // 扫描中，删除无效
                console.log('文件正在扫描中，不能删除');
            } else if (this.state === 'uploading') { // 上传中，删除无效
                console.log('文件正在上传中，不能删除');
            }
        };
    }
    ...
}
```

sign、uploading、pause、done、error、del 负责切换状态之后的具体行为实现，如改变按钮文本，调用插件做相应操作：

```js
class Upload {
    ...
    sign() {
        this.plugin.sign();
        this.button_1.innerHTML = '扫描中，任何操作无效';
        this.state = 'sign';
    }
    uploading() {
        this.plugin.uploading();
        this.button_1.innerHTML = '正在上传，点击暂停';
        this.state = 'uploading';
    }
    pause() {
        this.plugin.pause();
        this.button_1.innerHTML = '已暂停，点击继续上传';
        this.state = 'pause';
    }
    done() {
        this.plugin.done();
        this.button_1.innerHTML = '上传完成';
        this.state = 'done';
    }
    error() {
        this.button_1.innerHTML = '上传失败';
        this.state = 'error';
    }
    del() {
        this.plugin.del();
        this.dom.parentNode.removeChild(this.dom);
        console.log('删除完成');
    }
    ...
}
```

最后进行简单测试：

```js
const uploadObj = new Upload('JavaScript 从入门到精通');
uploadObj.init();

setTimeout(() => { // 假设 3s 后扫描完成，开始上传
    uploadObj.changeState('uploading');
}, 3000);

setTimeout(() => { // 假设 6s 后上传完成
    uploadObj.changeState('done');
}, 6000);
```

显而易见的是，这段代码与电灯示例相同，充斥着大量的 if else 分支，状态和行为都耦合在一个巨大的方法中，我们很难修改和扩展这个状态机，尤其在这个更为复杂的示例，问题也显得更为严重

#### 状态模式重构文件上传

首先 plugin 部分没有改变：

```js
const plugin = {
    sign() {
        console.log('开始文件扫描');
    },
    pause() {
        console.log('暂停文件上传');
    },
    uploading() {
        console.log('开始文件上传');
    },
    del() {
        console.log('删除文件上传');
    },
    done() {
        console.log('文件上传完成');
    },
};
```

接着我们模仿电灯示例，为每一种状态与其对应的行为，定义一个单独的类：

```js
class State {
    constructor(uploadObj) {
        this.uploadObj = uploadObj;
    }
    clickHandler_1() {
        throw new Error('子类必须重写父类的 clickHandler_1 方法');
    }
    clickHandler_2() {
        throw new Error('子类必须重写父类的 clickHandler_2 方法');
    }
}
// 扫描状态
class SignState extends State {
    clickHandler_1() {
        console.log('扫描中，点击无效...');
    }
    clickHandler_2() {
        console.log('文件正在上传中，不能删除');
    }
}
// 上传中状态
class UploadingState extends State {
    clickHandler_1() {
        this.uploadObj.pause();
    }
    clickHandler_2() {
        console.log('文件正在上传中，不能删除');
    }
}
// 暂停状态
class PauseState extends State {
    clickHandler_1() {
        this.uploadObj.uploading();
    }
    clickHandler_2() {
        this.uploadObj.del();
    }
}

// 完成状态
class DoneState extends State {
    clickHandler_1() {
        console.log('文件已完成上传, 点击无效');
    }
    clickHandler_2() {
        this.uploadObj.del();
    }
}

// 错误状态
class ErrorState extends State {
    clickHandler_1() {
        console.log('文件上传失败, 点击无效');
    }
    clickHandler_2() {
        this.uploadObj.del();
    }
}
```
有了单独的状态类，我们就需要调整 Upload 的 constructor，在 constructor 中为每一种状态都创建一个实例对象：

```js
class Upload {
    constructor(fileName) {
        this.plugin = plugin;
        this.fileName = fileName;
        this.dom = null;
        this.button_1 = null;
        this.button_2 = null;
        this.signState = new SignState(this);
        this.uploadingState = new UploadingState(this);
        this.pauseState = new PauseState(this);
        this.doneState = new DoneState(this);
        this.errorState = new ErrorState(this);
        this.currState = this.signState; // 设置当前状态为扫描中
    }
}
```

当然，init 初始化内容并不需要改变，依旧是负责挂载节点，绑定事件：

```js
class Upload {
    ...
    init() {
        this.dom = document.createElement('div');
        this.dom.innerHTML =
            `<span>文件名称: ${this.fileName}</span>
            <button>扫描中</button>
            <button>删除</button>`;
        document.body.appendChild(this.dom);
        const buttons = this.dom.querySelectorAll('button');
        this.button_1 = buttons[0];
        this.button_2 = buttons[1];

        this.bindEvent();
    }
    ...
}
```

现在 bindEvent 不再负责管理庞大的状态逻辑，而是将请求委托给当前状态对象来操作：

```js
class Upload {
    ...
    bindEvent() {
        this.button_1.onclick = () => this.currState.clickHandler_1();
        this.button_2.onclick = () => this.currState.clickHandler_2();
    }
    ...
}
```

最后我们拆分一下 changeState 方法
