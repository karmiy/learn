## 模板方法模式

模板方法模式：**封装一个算法的步骤，并允许子类为一个或多个步骤提供其实践方式，让子类在不改变算法架构的情况下重新定义算法中的某些步骤**

我们可以理解为：**封装了一个固定流程，该流程由几个步骤组成，具体步骤可以由子类进行不同的实现，从而让固定的流程产生不同的结果**

模板方法模式是**基于继承**的，它由 2 部分组成：

- 抽象父类

- 具体的实现子类

通常在抽象父类封装子类的算法框架，包括实现一些**公共方法**及封装子类中所有方法的**执行顺序**。子类通过继承抽象类，也就**继承了整个算法结构**，还可以选择**重写父类方法**

假设有一些平行的子类，它们都有一些相同的行为和不同的行为，如果这些相同的行为都在各个子类中实现，那显然是非常重复多余的。而模板方法模式就是将这些共性提取在模板类中，减少冗余。此外不同的行为还可以各自在子类中实现，达到泛化的效果

### 咖啡与茶的示例

我们先泡一杯咖啡，步骤如下：

- 把水煮沸

- 用沸水冲泡咖啡

- 把咖啡倒进杯子

- 加糖和牛奶

通过下面的代码，就可以得到这样的一杯咖啡：

    class Coffee {
        boilWater() {
            console.log('把水煮沸');
        }
        brewCoffeeGriends() {
            console.log('用沸水冲泡咖啡');
        }
        pourInCup() {
            console.log('把咖啡倒进杯子');
        }
        addSugarAndMilk() {
            console.log('加糖和牛奶');
        }
        init() {
            this.boilWater();
            this.brewCoffeeGriends();
            this.pourInCup();
            this.addSugarAndMilk();
        }
    }
    const coffee = new Coffee();
    coffee.init();

接着再泡一壶茶，步骤如下：

- 把水煮沸

- 用沸水浸泡茶叶

- 把茶水倒进杯子

- 加柠檬

同样用一段代码实现：

    class Tea {
        boilWater() {
            console.log('把水煮沸');
        }
        steepTeaBag() {
            console.log('用沸水浸泡茶叶');
        }
        pourInCup() {
            console.log('把茶水倒进杯子');
        }
        addLemon() {
            console.log('加柠檬');
        }
        init() {
            this.boilWater();
            this.steepTeaBag();
            this.pourInCup();
            this.addLemon();
        }
    }
    const tea = new Tea();
    tea.init();

很容易发现，泡咖啡和泡茶的过程是大同小异的

| 泡咖啡 | 泡茶 |
| ------ | ------ |
| 把水煮沸 | 把水煮沸 |
| 用沸水冲泡咖啡 | 用沸水浸泡茶叶 |
| 把咖啡倒进杯子 | 把茶水倒进杯子 |
| 加糖和牛奶 | 加柠檬 |

不同点：

- 原料不同，一个是茶一个是咖啡，但是可以把它们都抽象为**饮料**

- 泡的方式不同，咖啡是冲泡，茶叶是浸泡，但是可以把它们都抽象为**泡**

- 加入的调理不同，一个是糖和牛奶一个是柠檬，但是可以把它们都抽象为**调料**

经过抽象，不管是咖啡还是茶，都可以整理为：

- 把水煮沸（boilWater）

- 用沸水冲泡饮料（brew）

- 把饮料倒进杯子（pourInCup）

- 加调料（addCondiments）


现在我们可以创建一个抽象父类来表示泡一杯饮料的过程：

    class Beverage {
        boilWater() {
            console.log('把水煮沸');
        }
        brew() {} // 空方法，由子类重写
        pourInCup() {} // 空方法，由子类重写
        addCondiments() {} // 空方法，由子类重写
        init() {
            this.boilWater();
            this.brew();
            this.pourInCup();
            this.addCondiments();
        }
    }

有了抽象父类饮料还是不够的，创建一个 Beverage 并没有意义，需要做的是用它以继承的方式创建咖啡类和茶类

我们先实现咖啡类：

    class Coffee extends Beverage {
        brew() {
            console.log('用沸水冲泡咖啡');
        }
        pourInCup() {
            console.log('把咖啡倒进杯子');
        }
        addCondiments() {
            console.log('加糖和牛奶');
        }
    }

    const coffee = new Coffee();
    coffee.init();

当调用 coffee 对象的 init 方法时，由于 coffee 对象本身和其原型上没有 init，所以该请求会顺着原型链，委托给父类 Beverage 原型中的 init，而 Beverage 原型的 init 已经定义好了泡饮料的顺序，所以可以成功泡出一杯咖啡

茶类同理：

    class Tea extends Beverage {
        brew() {
            console.log('用沸水浸泡茶叶');
        }
        pourInCup() {
            console.log('把茶倒进杯子');
        }
        addCondiments() {
            console.log('加柠檬');
        }
    }

    const tea = new Tea();
    tea.init();

那么我们讨论的模板方法模式，在这个例子中，谁是**模板方法**？这里是 Beverage.prototype.init

因为 Beverage.prototype.init **封装了子类的算法框架，作为一个算法的模板，指导子类以何种顺序去执行哪些方法**

可以看到，Beverage.prototype.init 中，算法内每一个步骤都清楚的展示了出来

