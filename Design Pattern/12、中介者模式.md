## 中介者模式

中介者模式：**解除对象与对象之间的紧耦合关系，增加一个中介者对象，所有相关对象都通过中介者通信，而不是互相引用**

在程序中，一个对象可能会和其他 10 个对象打交道，它会保持 10 个对象的引用，当规模增加时，对象也会越来越多，它们之间的关系也会更为复杂。当我们改变或删除其中一个对象时，很可能需要通知所有引用到它的对象，这样即使一点小修改都要小心翼翼，这种关系结构可能如下图所示：

![Alt text](./imgs/12-01.png)

由于这些对象之间联系激增，同样也降低了它们的可复用性

中介者模式使各对象之间耦合松散，可以独立的改变它们之间的交互，中介者模式使网状的多对多关系变成相对简单的一对多关系：

![Alt text](./imgs/12-02.png)

在第一张图中，对象 A 发生变化，需要通过通知引用关系的 D、E、F。而在第二张图中引入了中介者，A 的变化只需要通知这个中介者对象即可

现实中也有需要中介者模式的影子：

- 如果没有机场的指挥塔，每一架飞机要和方圆 100 公里内的所有飞机通信才能确定航线及飞行状况，后果不可想象。而由于指挥塔的存在，每架飞机都只需和指挥塔通信，指挥塔作为调停者，知道每一架飞机的状况，所以它可以安排所有飞机的起降时间并在一些情况下即使做出调整

- 世界杯期间购买足球彩票，没有博彩公司作为中介的话，上千万人要一起计算赔率和输赢是不可能的，有了博彩公司，每个人只需和博彩公司发生关联，所有的投注情况和赔率计算都由这个中介完成

### 泡泡堂示例

#### 双人模式

现在我们来构思一个简易版泡泡堂，游戏之初只支持 2 个玩家

首先定义一个玩家类 Player，拥有 3 个方法：win、lose、die：

由于玩家数量是 2，那么只需要在其中一人死亡时结束游戏并通知对方胜利即可

```js
class Player {
    constructor(name) {
        this.name = name;
        this.enemy = null; // 敌人
    }
    win() {
        console.log(`${this.name} won`);
    }
    lose() {
        console.log(`${this.name} lost`);
    }
    die() {
        this.lose();
        this.enemy.win();
    }
}

const player1 = new Player('蓝妹妹');
const player2 = new Player('小乖');

player1.enemy = player2;
player2.enemy = player1;

player1.die(); 
// 输出：
// 蓝妹妹 lost 小乖 won
```

#### 8 人组队模式

现在改进一次，将人数变成 8 人，并分为红蓝两队

因为数量变多，用原来这种方式设置队友和敌人显然是低效的：

```js
player1.partners= [player1,player2,player3,player4]; 
player1.enemies = [player5,player6,player7,player8]; 
Player5.partners= [player5,player6,player7,player8]; 
Player5.enemies = [player1,player2,player3,player4];
```

所以这里采用定义数组 players 保存所有玩家，玩家创建后循环 players 给每个玩家设置队友和敌人

此外还可以定义一个工厂函数来创建 player：

```js
const players = [];

class Player {
    constructor(name, teamColor) {
        this.name = name;
        this.partners = []; // 队友
        this.enemies = []; // 敌人
        this.state = 'alive';
        this.teamColor = teamColor;
    }
    win() {
        console.log(`${this.name} won`);
    }
    lose() {
        console.log(`${this.name} lost`);
    }
    die() {
        this.state = 'dead';
        const all_dead = this.partners.every(partner => partner.state === 'dead');
        if (all_dead) {
            this.lose();
            this.partners.forEach(partner => partner.lose());
            this.enemies.forEach(ememy => ememy.win());
        }
    }
}
const playerFactory = function(name, teamColor) {
    const newPlayer = new Player(name, teamColor);
    players.forEach(player => {
        if (player.teamColor === newPlayer.teamColor) {
            player.partners.push(newPlayer);
            newPlayer.partners.push(player);
        } else {
            player.enemies.push(newPlayer);
            newPlayer.enemies.push(player);
        }
    });
    players.push(newPlayer);
    return newPlayer;
}
```

创建 8 名玩家，组成 2 队：

```js
// 红队
const player1 = playerFactory('皮蛋', 'red'),
    player2 = playerFactory('小乖', 'red'),
    player3 = playerFactory('宝宝', 'red'),
    player4 = playerFactory('小强', 'red');

// 蓝队
const player5 = playerFactory('黑妞', 'blue'),
    player6 = playerFactory('葱头', 'blue'),
    player7 = playerFactory('胖墩', 'blue'),
    player8 = playerFactory('海盗', 'blue');

player1.die();
player2.die();
player3.die();
player4.die();
// 输出：
// 小强 lost
// 皮蛋 lost
// 小乖 lost
// 宝宝 lost
// 黑妞 won
// 葱头 won
// 胖墩 won
// 海盗 won
```

#### 玩家增加带来的困扰

可以看到，现在每个玩家和其他玩家都是**紧耦合**的

partners 和 enemies 保存着其他对象的引用，当一个对象的状态改变时，需要**显示**通知其他对象

如果是在一个大型游戏里有着成百上千的玩家，几十支队伍，当其中一名玩家掉线时，需要从所有的队友和敌人列表移除，甚至有的游戏还有切换队伍的功能，让玩家从红队变为蓝队，那这就不仅仅是循环能解决的了，可见我们上面实现的代码是不健壮

#### 中介者模式改造

![Alt text](./imgs/12-03.png)

中介者对象命名为 playerDirector，它向外抛出了 reciveMessage 方法，让 Player 可以通知它进行相应的行为操作

首先需要重构 Player，Player 不再负责具体执行逻辑，而是将这些操作交给中介者，同时我们为 Player 新增 remove 和 changeTeam 方法，方便玩家移除列表和切换队伍

```js
class Player {
    constructor(name, teamColor) {
        this.name = name;
        this.state = 'alive';
        this.teamColor = teamColor;
    }
    win() {
        console.log(`${this.name} won`);
    }
    lose() {
        console.log(`${this.name} lost`);
    }
    die() {
        this.state = 'dead';
        // 给中介者发送消息，该玩家死亡
        playerDirector.reciveMessage('playerDead', this);
    }
    remove() {
        // 给中介者发送消息，移除该玩家
        playerDirector.reciveMessage('removePlayer', this);
    }
    changeTeam(color) {
        // 给中介者发送消息，该玩家换队
        playerDirector.reciveMessage('changeTeam', this, color);
    }
}
```
接着同样改写 playerFactory，由工厂创建 player 后向中介者发送新增玩家的消息：

```js
const playerFactory = function(name, teamColor) {
    const newPlayer = new Player(name, teamColor);
    playerDirector.reciveMessage('addPlayer', newPlayer);
    return newPlayer;
}
```

最后实现中介者 playerDirector，一般有以下 2 种方式：

- 使用观察者模式，playerDirector 作为订阅方，各 player 作为发布方，player 状态改变时推送消息给 playerDirector，playerDirector 处理后将反馈发送给其他 player

- playerDirector 开放一些接收消息的接口，player 可以直接调用接口发送消息，player 只需传递一个标识行为的参数，playerDirector 处理消息后将反馈发送给其他 player

从上面的代码可以看到，这里我们使用第二种方式，对外暴露 reciveMessage 接口：

```js
const playerDirector = (function() {
    const players = {}; // 所有玩家，key 为 teamColor
    const operations = {}; // 中介者可以执行的操作
    
    // 新增玩家
    operations.addPlayer = function(player) {
        const teamColor = player.teamColor;
        // 还未成立队伍则立即创建
        players[teamColor] = players[teamColor] || [];
        players[teamColor].push(player);
    }

    // 移除玩家
    operations.removePlayer = function(player) {
        const teamColor = player.teamColor;
        const teamPlayers = players[teamColor] || []; // 对应队伍
        teamPlayers.splice(teamPlayers.indexOf(player), 1);
    }

    // 玩家换队
    operations.changeTeam = function(player, teamColor) {
        operations.removePlayer(player);
        player.teamColor = teamColor;
        operations.addPlayer(player);
    }

    // 玩家死亡
    operations.playerDead = function(player) {
        const teamColor = player.teamColor,
            teamPlayers = players[teamColor];
        
        const all_dead = teamPlayers.every(player => player.state === 'dead');
        if(all_dead) {
            // 本队玩家全部 lose
            teamPlayers.forEach(player => player.lose());
            
            // 其他队伍全部玩家 win
            for(let color in players) {
                if(color !== teamColor) {
                    const teamPlayers = players[color];
                    teamPlayers.forEach(player => player.win());
                }
            }
        }
    }

    const reciveMessage = function(message, ...args) {
        operations[message].apply(this, args);
    }
    return {
        reciveMessage,
    }
}());
```

现在创建 8 名玩家，测试队伍全家全部死亡：

```js
// 红队
const player1 = playerFactory('皮蛋', 'red'),
    player2 = playerFactory('小乖', 'red'),
    player3 = playerFactory('宝宝', 'red'),
    player4 = playerFactory('小强', 'red');

// 蓝队
const player5 = playerFactory('黑妞', 'blue'),
    player6 = playerFactory('葱头', 'blue'),
    player7 = playerFactory('胖墩', 'blue'),
    player8 = playerFactory('海盗', 'blue');

player1.die(); 
player2.die(); 
player3.die(); 
player4.die();
// 输出：
// 皮蛋 lost
// 小乖 lost
// 宝宝 lost
// 小强 lost
// 黑妞 won
// 葱头 won
// 胖墩 won
// 海盗 won
```

测试掉线：
```js
player1.remove(); 
player2.remove(); 
player3.die(); 
player4.die();
// 输出：
// 宝宝 lost
// 小强 lost
// 黑妞 won
// 葱头 won
// 胖墩 won
// 海盗 won
```

测试换队：
```js
player1.changeTeam('blue'); 
player2.die(); 
player3.die(); 
player4.die();
// 输出：
// 小乖 lost
// 宝宝 lost
// 小强 lost
 // 黑妞 won
 // 葱头 won
 // 胖墩 won
 // 海盗 won
 // 皮蛋 won
```
使用中介者模式重构了代码后，我们不管是实现原来的队伍输赢通知，还是新增的移除、换队都非常的简单

### 手机购买示例

假如现在在开发一个手机购买页面，这个需求有如下场景

库存不足：

![Alt text](./imgs/12-04.png)

库存充足，可加入购物车：

![Alt text](./imgs/12-05.png)

没有输入数量：

![Alt text](./imgs/12-06.png)

没有选择手机颜色：

![Alt text](./imgs/12-07.png)

根据图中场景可以了解到，这个页面需要 5 个节点：

- 颜色下拉选择框 colorSelect

- 购买数量输入框 numberInput

- 选择的颜色信息 colorInfo

- 选择的购买数量信息 numberInfo

- 操作按钮 nextBtn

页面 HTML 结构：

```html
<body>
    <div class="wrap">
        <form class="form-inline">
            <div class="form-group">
                <label>颜色：</label>
                <select id="colorSelect" class="form-control">
                    <option value="">请选择</option>
                    <option value="blue">蓝色</option>
                    <option value="red">红色</option>
                </select>
            </div>
            <div class="form-group">
                <label>购买数量：</label>
                <input id="numberInput" class="form-control" placeholder="请输入">
            </div>
        </form>
        <form class="form-inline mt-3">
            <div class="form-group">
                <label>您选择了颜色：</label>
                <span id="colorInfo">blue</span>
            </div>
        </form>
        <form class="form-inline mt-3">
            <div class="form-group">
                <label>您输入了数量：</label>
                <span id="numberInfo"></span>
            </div>
        </form>
        <button type="button" id="nextBtn" class="btn btn-default mt-3" disabled="disabled">请选择手机颜色</button>
    </div>
</body>
```

现在开始编写业务逻辑

