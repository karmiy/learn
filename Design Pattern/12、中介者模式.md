## 中介者模式

中介者模式：**解除对象与对象之间的紧耦合关系，增加一个中介者对象，所有相关对象都通过中介者通信，而不是互相引用**

在程序中，一个对象可能会和其他 10 个对象打交道，它会保持 10 个对象的引用，当规模增加时，对象也会越来越多，它们之间的关系也会更为复杂。当我们改变或删除其中一个对象时，很可能需要通知所有引用到它的对象，这样即使一点小修改都要小心翼翼，这种关系结构可能如下图所示：

![Alt text](./imgs/12-01.png)

由于这些对象之间联系激增，同样也降低了它们的可复用性

中介者模式使各对象之间耦合松散，可以独立的改变它们之间的交互，中介者模式使网状的多对多关系变成相对简单的一对多关系：

![Alt text](./imgs/12-02.png)

在第一张图中，对象 A 发生变化，需要通过通知引用关系的 D、E、F。而在第二张图中引入了中介者，A 的变化只需要通知这个中介者对象即可

现实中也有需要中介者模式的影子：

- 如果没有机场的指挥塔，每一架飞机要和方圆 100 公里内的所有飞机通信才能确定航线及飞行状况，后果不可想象。而由于指挥塔的存在，每架飞机都只需和指挥塔通信，指挥塔作为调停者，知道每一架飞机的状况，所以它可以安排所有飞机的起降时间并在一些情况下即使做出调整

- 世界杯期间购买足球彩票，没有博彩公司作为中介的话，上千万人要一起计算赔率和输赢是不可能的，有了博彩公司，每个人只需和博彩公司发生关联，所有的投注情况和赔率计算都由这个中介完成

### 泡泡堂示例

#### 双人模式

现在我们来构思一个简易版泡泡堂，游戏之初只支持 2 个玩家

首先定义一个玩家类 Player，拥有 3 个方法：win、lose、die：

由于玩家数量是 2，那么只需要在其中一人死亡时结束游戏并通知对方胜利即可

```js
class Player {
    constructor(name) {
        this.name = name;
        this.enemy = null; // 敌人
    }
    win() {
        console.log(`${this.name}won`);
    }
    lose() {
        console.log(`${this.name}lost`);
    }
    die() {
        this.lose();
        this.enemy.win();
    }
}

const player1 = new Player('蓝妹妹');
const player2 = new Player('小乖');

player1.enemy = player2;
player2.enemy = player1;

player1.die(); 
// 输出
// 蓝妹妹lost 小乖won
```

#### 8 人组队模式

现在改进一次，将人数变成 8 人，并分为红蓝两队

因为数量变多，用原来这种方式设置队友和敌人显然是低效的：

```js
player1.partners= [player1,player2,player3,player4]; 
player1.enemies = [player5,player6,player7,player8]; 
Player5.partners= [player5,player6,player7,player8]; 
Player5.enemies = [player1,player2,player3,player4];
```

所以这里采用定义数组 players 保存所有玩家，玩家创建后循环 players 给每个玩家设置队友和敌人