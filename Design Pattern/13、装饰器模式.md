## 装饰器模式

装饰器模式：**为一个现有对象动态增加新的职责，同时又不改变其结构的的方式**

在传统面向对象语言中，对对象添加功能通常使用**继承**的方式

但是继承并不灵活，还存在一些问题：

- 超类和子类强耦合，超类改变影响子类随之改变

- 白箱复用，超类的内部细节对子类可见，破坏了封装性

- 子类数量爆炸式增长，假设现在有 4 种自行车，我们为每一种自行车定义单独的类，现在要添加前灯、尾灯、铃铛 3 种配置，继承的实现将会创建 12 种子类

而装饰器模式在于**动态增加职责**，它能够在不改变对象自身的基础上，给对象动态添加功能，而不是一开始就有这个功能

生活中也要很多装饰器的场景：

- 游戏中角色升级后进行技能加点，人物角色往往不是一开始就具有那些技能的，而是通过技能加点，按需装上这些功能

- 天冷了，我们就多穿一件衣服，而不是一开始我们本身就穿着这件衣服

- 哆啦A梦要飞行功能，就在头上安装一个竹蜻蜓

可以体会到，装饰器与继承相比，是一种**更轻便灵活**的做法

### 模拟传统面向对象语言的装饰器模式

假设现在正在实现一个飞机游戏的需求，一开始飞机只能发射普通子弹，随着升级过程，飞机进化为可以发射导弹，再升级便可以发射原子弹

在传统面向对象语言是如何使用装饰器模式实现这个需求的？

排除静态类型检测、抽象类、接口等，主要的做法用 JavaScript 实现效果如下：

```js
class Plane {
    fire() {
        console.log('发射普通子弹');
    }
}

// 导弹装饰器类
class MissileDecorator {
    constructor(plane) {
        this.plane = plane;
    }
    fire() {
        this.plane.fire();
        console.log('发射导弹');
    }
}

// 原子弹装饰器类
class AtomDecorator {
    constructor(plane) {
        this.plane = plane;
    }
    fire() {
        this.plane.fire();
        console.log('发射原子弹');
    }
}

let plane = new Plane();
plane = new MissileDecorator(plane);
plane = new AtomDecorator(plane);
plane.fire();

// 输出：发射普通子弹 发射导弹 发射原子弹
```

可以看到，实现思路在于：**将对象放入另一个对象之中，这些对象以一条链的方式进行引用，形成一个聚合对象**

这种给对象动态增加职责的方式，并没有真正改动对象自身

这些对象都拥有相同的接口（如这里 fire），当请求达到链中某个对象时，这个对象会执行自身操作，随后把请求转发给链中下一个对象

因为装饰器对象和所修饰的对象拥有一致接口，所以对用户而言是透明的，被装饰的对象也不需要了解它被装饰过，这种透明性使得我们可以递归嵌套任意多个装饰器对象

**装饰器（decorator）也是包装器（wrapper）**，从结构上看，装饰器模式将一个对象嵌入另一个对象，相当于这个对象被包装了起来，形成一条包装链

![Alt text](./imgs/13-01.png)

### JavaScript 的装饰器

在 JavaScript 中动态修改对象相对容易，我们可以直接**改写对象或对象的某个方法**，并不需要使用类来实现装饰器模式：

```js
const plane = {
    fire() {
        console.log('发射普通子弹');
    },
}

const missileDecorator = function() {
    console.log('发射导弹');
}

const atomDecorator = function() {
    console.log('发射原子弹');
}

const fire_1 = plane.fire;
plane.fire = function() {
    fire_1();
    missileDecorator();
}

const fire_2 = plane.fire;
plane.fire = function() {
    fire_2();
    atomDecorator();
}

plane.fire();

// 输出：发射普通子弹 发射导弹 发射原子弹
```

### 装饰函数

在 JavaScript 中，我们可以很方便的某个对象扩展属性和方法

如为对象扩展 say 方法：

```js
const obj = {};
obj.say = function() {
    ...
}
```

我们很容易做到**在不改变对象源码的情况下扩展属性**

但是在 JavaScript 有一个特殊对象：**函数**。函数在 JavaScript 中作为一等对象，在开发中大部分时间也都在与函数打交道

相比对象，**在不改动某个函数源码的情况下，给函数添加新功能是相对困难的**

最简单的做法就是直接改写函数：

```js
function fn() {
    console.log(1);
}

// 为函数 fn 扩展打印 2 的功能
function fn() {
    console.log(1);
    console.log(2);
}
```

这样的做法存在很明显的缺陷：

- 违背开放封闭原则

- 在获取不到源码的情况下无法实现

我们更需要的是在不修改源码的情况下扩展函数功能

其实在上一节我们已经这么做了：**通过保存原函数的引用来改写函数**（上一节 fire_1 保存了原 plane.fire 的引用）

这是实际开发中一种很常见的做法，比如我们需要为 window.onload 新增功能，但是不确定这个事件是否已经在项目某处被绑定过，为了避免覆盖之前的行为，可能会这样做：

```js
window.onload = function() {
    console.log(1);
}

const _onload = window.onload || function() {}

window.onload = function() {
    _onload();
    console.log(2);
}
```

这样的代码是**符合开放-封闭原则**的，但是其实还是存在一些问题：

- 必须维护 _onload 中间变量，如果函数装饰链较长，中间变量也会越来越多

- this 指向问题，当我们装饰的函数内需要 this 指向时可能导致运行报错，需要手动绑定 this，不方便

```js
const _getElementById = document.getElementById;
document.getElementById = function(id) {
    console.log(1);
    return _getElementById(id);
}
const button = document.getElementById('button'); // 报错

// 解决
const _getElementById = document.getElementById;
document.getElementById = function(id) {
    console.log(1);
    return _getElementById.call(document, id);;
}
const button = document.getElementById('button');
```
### AOP 装饰函数

除了保存引用的方式装饰函数，还可以使用 AOP 对函数进行装饰

```js
Function.prototype.before = function(beforeFn) {
    const _self = this; // 保存原函数引用
    return function(...args) {
        beforeFn.apply(this, args);
        return _self.apply(this, args);
    }
}

Function.prototype.after = function(afterFn) {
    const _self = this; // 保存原函数引用
    return function(...args) {
        const ret = _self.apply(this, args);
        afterFn.apply(this, args);
        return ret
    }
}
```

改写 window.onload 示例：

```js
window.onload = function() {
    console.log(1);
}

window.onload = (window.onload || function() {}).after(function() {
                    console.log(2);
                }).after(function() {
                    console.log(3);
                }).after(function() {
                    console.log(4);
                });
```

改写 document.getElementById 示例：

```js
document.getElementById = document.getElementById.before(function() {
    console.log(1);
});
const button = document.getElementById('button');
```

可以看到装饰函数非常方便，如果我们不想污染原型的做法，可以单独创建函数 before、after：

```js
const before = function(fn, beforeFn) {
    return function(...args) {
        beforeFn.apply(this, args);
        return fn.apply(this, args);
    } 
}

const after = function(fn, afterFn) {
    return function(...args) {
        const ret = fn.apply(this, args);
        afterFn.apply(this, args);
        return ret;
    } 
}

document.getElementById = before(document.getElementById, function() {
    console.log(1);
});
```

在实际开发中，不论是业务代码，还是框架层面，我们都可以**把行为根据职责分割为粒度更细的函数**，随后将他们装饰在一起，这对编写一个松耦合高复用性的代码有很大帮助

#### 数据统计上报示例

有不少公司都会有埋点数据统计的需求，网站希望知道用户对什么信息更感兴趣（服务器、负载均衡），这就需要前端进行数据采集，而后台系统中根据采集的数据生成图表，这样公司就可以对用户需求进行分析，更好的规划自己的产品

常见的实现思路是：**点击按钮后将 button 上的标识利用 img 发送给后端**

这是因为：

- 埋点不关心请求结果，只做发送

- img 可以跨域

- 无需 ajax 只能达到请求效果

- 原生实现兼容性良好

假设现在正在实现这样的埋点需求，页面上有一个登录 button，点击会弹出登录框，现在要对它进行数据上报，代码实现如下：





