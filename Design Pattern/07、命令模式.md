## 命令模式

命令模式：**将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化**

这就如一家餐厅点菜，客人点餐后，服务员会把需求写在清单上，然后交给厨房，**客人不关心是哪个厨师帮他做菜。客人和厨师之间是解耦的**

并且餐厅还可以满足**定时服务**，比如要求 1 小时后开始做菜，只要订单在，厨师就不会忘记

同样客人还可以很方便的**撤销订单**

另外如果有很多的客人点菜，厨房可以**按订单顺序排队**做菜

这些记录订单信息的清单，就是**命令模式的命令对象**

### 命令模式的作用

命令模式中的命令是指：**一个执行某些特定事情的指令**

有时需要向某些对象发送请求，但并不知道请求的接收者是谁，也不知道被请求的操作是什么，命令模式希望做到的是：**用一种松耦合的方式，使得请求发送者和接收者能消除彼此的耦合关系**

就如上例中的订餐，客人需要向厨师发送请求，但是完全不知道厨师的名字和联系方式，也不知道厨师做菜的方式。命令模式把客人的订餐请求封装成 command 对象，这个对象可以被四处传递，就像从服务员手中传到厨师手中，这样厨师只需要根据 command 对象去执行命令即可，**解开了请求调用者和接收者之间的耦合关系**

另外，command 对象相对于过程化的请求调用（客人对象直接调用厨师对象的做菜接口）**拥有更长的生命周期**，对象的生命周期跟请求无关，我们可以在程序中任意时刻调用这个方法，就像定时功能 1 小时后在做菜，相当于 1 小时后在执行 command 对象的方法

对于命令模式，请求者发起请求后会发生一些事情是**不变**的，具体发生什么事情是**可变**，通过 command 对象的帮助，将来我们可以轻易的改变这种关联

可以知道，命令模式的作用在于：

- 请求者与接受者解耦

- 命令单独作为对象，拥有更长的生命周期，方便我们个性化操作

### 按钮点击示例

假设我们正在编写用户界面，界面上有数十个 Button 按钮，由于项目复杂，进行了如下分工：

- 一些开发人员负责绘制 Button 按钮（DOM、样式等）

- 一些开发人员负责编写点击按钮后的具体行为

可以看到，对于绘制按钮的人员来说，他完全不知某个按钮未来将用来做什么，可能是刷新页面，可能是新增菜单

下面使用命令模式实现需求

在页面完成按钮的绘制：

    <button id="button1">点击按钮 1</button>
    <button id="button2">点击按钮 2</button> 
    <button id="button3">点击按钮 3</button>

定义 setCommand 函数，负责往按钮上安装命令。可以肯定的是，点击按钮会执行某个 command 命令，执行的动作**被约定为调用 command 对象的 execute() 方法**：

    const setCommand = function(button, command) { 
        button.onclick = function() { 
            command.execute(); 
        }
    };

具体行为封装在各自对象中，刷新界面、增加子菜单、删除子菜单被分布在了 MenuBar 和 SubMenu 对象中：

    const MenuBar = {
        refresh() {
            console.log('刷新菜单目录');
        }
    };
    const SubMenu = {
        add() {
            console.log('增加子菜单');
        },
        del() {
            console.log('删除子菜单');
        }
    };

接着把这些行为都封装在命令类中：

    class Command {
        constructor(receiver) {
            this.receiver = receiver;
        }
    }
    class RefreshMenuBarCommand extends Command {
        execute() {
            this.receiver.refresh();
        }
    }

    class AddSubMenuCommand extends Command {
        execute() {
            this.receiver.add();
        }
    }

    class DelSubMenuCommand extends Command {
        execute() {
            this.receiver.del();
        }
    }

最后将命令接受者传入 commmand 对象，