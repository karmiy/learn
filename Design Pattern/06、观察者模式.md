## 观察者模式

观察者模式：定义对象间的一种一对多依赖关系，当一个对象状态发生改变时，所有依赖它的对象都将得到通知

生活中，也有很多观察者模式的实际场景：

A 希望购买某楼盘的房子，而现在该楼盘的房子早已售罄，于是 A 每隔一段时间 A 都要去售楼处询问是否有房源，如果购房者不止 A 一个，可能还有 B、C、D、E、F，那很明显，售房处会被问的厌倦

于是，正确的场景应该是：

A 等人将自己的联系方式给了售房处，等有了房源时由售房处主动通知购房者 A、B、C、D、E、F ，这种发布通知的方式就是观察者模式，而售房处即**发布者**、购房者为**订阅者**

### 观察者模式的作用

可以发现，观察者模式的优点在于：

- 由订阅者不需要不断的去调用发布者的接口，只需要由发布者通知这些消息订阅者

- 发布者与订阅者不再强耦合，而是处于一对多的关系（一个发布者，多个订阅者），订阅者只需要提供给发布者统一的信息（如购房者统一提供联系方式），发布者不需要去知道订阅者是谁（是男人、女人、什么身份等），只需要发布消息给对方即可

第一个优点可以广泛的应用于**异步编程**，这是一种替代传递回调函数的方案（回调函数一般只是作为一个参数，即一对一的关系，观察者模式可以一对多，在我们需要的事件发生点进行订阅）。如 ajax 请求的 success、error 事件等

第二个优点可以取代对象之间硬编码的通知机制（一个对象不再显示去调用另一个对象的接口，如 a 对象直接调用 b.say()，与 b 强耦合），观察者模式让两个对象之间**松耦合**，虽然**不清楚彼此的细节，但不影响它们通讯**。当新的订阅者加入时也不需要修改发布者的代码（强耦合的话，如果加入了 c，就需要又去加一行 c.say()），同样发布者需要修改时，也不会影响到之前的订阅者，只要**约定的事件名**没有变化，就可以自由改变它们

### DOM 事件

实际上，我们在平时开发中经常使用过观察者模式：

    document.body.addEventListener('click', function() {
        console.log(1);
    }, false);
    document.body.click(); // 发布通知

在这里我们监控用户点击 document.body 的动作，但是我们并不能预知将在什么时候点击。于是我们订阅了 document.body 的 click 事件，当被点击时，body 节点就会向订阅者发布这个消息。这就很像购房例子，购房者不知房子什么时候开售，于是订阅消息后等售房处发布消息

此外我们还可以随意**新增或删除订阅者**，增加任何订阅者都不会影响发布者代码的编写：

    document.body.addEventListener('click', function() {
        console.log(1);
    }, false);

    document.body.addEventListener('click', function() {
        console.log(2);
    }, false);

    document.body.addEventListener('click', function() {
        console.log(3);
    }, false);

    document.body.addEventListener('click', function() {
        console.log(4);
    }, false);

    document.body.click();

### 购房示例

这里来看看观察者模式在购房示例的应用，首先确定流程：

- 售楼处是发布者

- 发布者需要一个**缓存**，存放回调函数以通知订阅者

- 发布消息时，发布者遍历缓存列表，依次触发存放订阅者的回调

``````````````
const salesOffices = {}; // 定义售楼处
salesOffices.clientList = []; // 缓存列表，存放订阅者的回调函数
salesOffices.listen = function(fn) { // 增加订阅者
    this.clientList.push(fn); // 订阅的消息添加进缓存列表
};
salesOffices.trigger = function(...args) { // 发布消息
    this.clientList.forEach(fn => fn(...args));
};

salesOffices.listen(function(price, squareMeter) { // A 订阅消息
    console.log('价格= ' + price);
    console.log('平方米= ' + squareMeter);
});

salesOffices.listen(function(price, squareMeter) { // B 订阅消息
    console.log('价格= ' + price);
    console.log('平方米= ' + squareMeter);
});

salesOffices.trigger(2000000, 88);
// A、B 都接收到消息：价格= 2000000 平方米= 88
``````````````