## 迭代器模式

迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示

    const arr_1 = [1, 2, 3, 4];
    for(let i = 0, len = arr_1.length; i < len; i++) {
        // 逻辑操作 1 ...
    }

    const arr_2 = [10, 20, 30, 40];
    for(let i = 0, len = arr_2.length; i < len; i++) {
        // 逻辑操作 2 ...
    }

上例中都是在遍历数组，然后各自进行不同的逻辑操作，这是将迭代操作职责和业务逻辑部分直接关联在了一起

- 我们遍历一个对象的操作，即迭代这个职责是**不变**的

- 迭代后每一项做的业务是**变化**的

迭代器模式是把**迭代过程从业务逻辑分离**，我们不关心对象的内部结构，也可以按顺序访问其中的每个元素

![Alt text](./imgs/05-01.png)

现在流行的大部分语言如 Java 等都已经有内置的迭代器实现，JavaScript 也有如 Array.prototype.forEach

### jQuery 的迭代器

迭代器模式无非就是循环访问聚合对象中的各个元素

jQuery 中 $.each 就是迭代器：

    $.each([1, 2, 3], function( i, n ) { 
        console.log( '当前下标为： '+ i ); 
        console.log( '当前值为:' + n ); 
    });

### 实现迭代器

我们也可以自己封装迭代职责：

    const each = function(ary, callback) {
        for (let i = 0, l = ary.length; i < l; i++) {
            callback.call(ary[i], i, ary[i]);
        }
    };

    each([1, 2, 3], function(i, n) {
        alert([i, n]);
    });

### 内部迭代器

刚刚编写的 each 就是内部迭代器

each 内部已经定义好了迭代规则，**完全接手整个迭代过程**，外部只需要一次初始调用

优点：

- 内部迭代器调用非常方便

- 外界不需要关心迭代器内部实现

- 外界跟迭代交互也仅是一次初始调用

缺点：

- 迭代规则已经被提前规定，如我们的 each 只能接收一个数组，接收特定的参数，无法同时迭代 2 个数组

例如我们要判断 2 个数组是否相等，如果不改写 each 本身代码，只能从回调函数入手：

    const compare = function(ary1, ary2) {
        if (ary1.length !== ary2.length) {
            throw new Error('不相等');
        }
        each(ary1, function(index, item) {
            if (item !== ary2[index]) {
                throw new Error('不相等');
            }
        });
        console.log('相等');
    }s

    compare([1, 2], [1, 2]) //  '相等'

其实这个 compare 的实现方式并不是很好，并且我们能实现它，还是因为 JavaScript 可以把函数作为参数传递，在其他语言未必这么幸运

### 外部迭代器

外部迭代器必须**显示**的请求迭代下一个元素

优点：

- 增强了迭代器的灵活性

缺点：

- 增加了调用的复杂度

下面继续用 compare 函数的实现来理解外部迭代器：

