## 迭代器模式

迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示

    const arr_1 = [1, 2, 3, 4];
    for(let i = 0, len = arr_1.length; i < len; i++) {
        // 逻辑操作 1 ...
    }

    const arr_2 = [10, 20, 30, 40];
    for(let i = 0, len = arr_2.length; i < len; i++) {
        // 逻辑操作 2 ...
    }

上例中都是在遍历数组，然后各自进行不同的逻辑操作，这是将迭代操作职责和业务逻辑部分直接关联在了一起

- 我们遍历一个对象的操作，即迭代这个职责是**不变**的

- 迭代后每一项做的业务是**变化**的

迭代器模式是把**迭代过程从业务逻辑分离**，我们不关心对象的内部结构，也可以按顺序访问其中的每个元素

![Alt text](./imgs/05-01.png)

现在流行的大部分语言如 Java 等都已经有内置的迭代器实现，JavaScript 也有如 Array.prototype.forEach

### jQuery 的迭代器

迭代器模式无非就是循环访问聚合对象中的各个元素

jQuery 中 $.each 就是迭代器：

    $.each([1, 2, 3], function( i, n ) { 
        console.log( '当前下标为： '+ i ); 
        console.log( '当前值为:' + n ); 
    });

### 实现迭代器

我们也可以自己封装迭代职责：

    const each = function(ary, callback) {
        for (let i = 0, l = ary.length; i < l; i++) {
            callback(i, ary[i]);
        }
    };

    each([1, 2, 3], function(i, n) {
        console.log(i, n);
    });

### 内部迭代器

刚刚编写的 each 就是内部迭代器

each 内部已经定义好了迭代规则，**完全接手整个迭代过程**，外部只需要一次初始调用

优点：

- 内部迭代器调用非常方便

- 外界不需要关心迭代器内部实现

- 外界跟迭代交互也仅是一次初始调用

缺点：

- 迭代规则已经被提前规定，如我们的 each 只能接收一个数组，接收特定的参数，无法同时迭代 2 个数组

例如我们要判断 2 个数组是否相等，如果不改写 each 本身代码，只能从回调函数入手：

    const compare = function(ary1, ary2) {
        if (ary1.length !== ary2.length) {
            throw new Error('不相等');
        }
        each(ary1, function(index, item) {
            if (item !== ary2[index]) {
                throw new Error('不相等');
            }
        });
        console.log('相等');
    }s

    compare([1, 2], [1, 2]) //  '相等'

其实这个 compare 的实现方式并不是很好，并且我们能实现它，还是因为 JavaScript 可以把函数作为参数传递，在其他语言未必这么幸运

### 外部迭代器

外部迭代器必须**显示**的请求迭代下一个元素

优点：

- 增强了迭代器的灵活性

缺点：

- 增加了调用的复杂度

下面继续用 compare 函数的实现来理解外部迭代器：

    const Iterator = function(obj) {
        let current = 0;
        const len = obj.length;
        const next = () => current += 1;
        const isDone = () => current >= len;
        const getCurrItem = () => obj[current];
        return {
            next,
            isDone,
            getCurrItem,
        }
    };

    const compare = function(iterator1, iterator2) {
        while (!iterator1.isDone() || !iterator2.isDone()) {
            if (iterator1.getCurrItem() !== iterator2.getCurrItem()) {
                throw new Error('iterator1 和 iterator2 不相等');
            }
            iterator1.next();
            iterator2.next();
        }
        console.log('相等');
    }

    compare(Iterator([1, 2]), Iterator([1, 2]));

可以看到，外部迭代器虽然调用方式比较复杂，需要手动迭代，但是相对的适用面也更广更灵活，也能满足更多变需求

内部迭代器与外部迭代器没有优劣之分，重在选择合适的场景

### 迭代类数组和字面量对象

迭代器不仅可以迭代数组，还可以迭代类数组，只要聚合对象有 length，且可以通过下标访问

除此之外，还可以迭代字面量对象，在 JavaScript 中可以用 for in 语句迭代字面量对象

如 jQuery 的 each 方法就是封装了各种迭代行为，下面我们看它代码是怎么实现的：

    $.each = function(obj, callback) {
        var value,
            i = 0,
            length = obj.length,
            isArray = isArraylike(obj);
        if (isArray) { // 迭代类数组
            for (; i < length; i++) {
                value = callback.call(obj[i], i, obj[i]);
                if (value === false) {
                    break;
                }
            }
        } else {
            for (i in obj) { // 迭代 object 对象
                value = callback.call(obj[i], i, obj[i]);
                if (value === false) {
                    break;
                }
            }
        }
        return obj;
    };

### 倒序迭代器

迭代器模式是为了提供访问聚合对象中每个元素的方法，没有规定以什么样的顺序来遍历聚合对象，这意味着也可以倒序迭代

下面我们实现倒序迭代：

    const reverseEach = function(ary, callback) {
        for (let l = ary.length - 1; l >= 0; l--) {
            callback(l, ary[l]);
        }
    };
    reverseEach([0, 1, 2], function(i, n) {
        console.log(n);
    });

### 中止迭代器

迭代器可以像 for 循环中 break 一样，提供跳出循环的方法

在“迭代类数组和字面量对象”的 jQuery 代码示例中，可以看到 jQuery 的 each 方法约定了回调返回 false，则提前终止循环

下面我们将自己的 each 也改写变为可中止的迭代器：

    const each = function(ary, callback) {
        for (let i = 0, l = ary.length; i < l; i++) {
            if(callback(i, ary[i]) === false) break;
        }
    };

    each([1, 2, 3], function(i, n) {
        if(i > 1) return false;
        console.log(i, n);
    });