## 学习来源

- 《曾探. JavaScript 设计模式与开发实践》

## 什么是设计模式

设计模式是：**在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案**

简单来说，设计模式是在**某种场合**下对**某个问题**的一种**解决方案**，而每一种设计模式，是对这些解决方案的**取名**

为什么要对这些解决方案取名？

- 在计算直角三角形斜边时，可以利用两边平方和的平方根获知，而这个操作叫做”勾股定理“。这样在之后遇到要求直角三角形的斜边时，就可以反射性的想到：”可以使用勾股定理去算“

- 足球场上教练指挥队友：“用速度突破对方边后卫之后，往球门方向踢出高球，中路接应队员抢点头球攻门”，而这样的战术其实叫作“下底传中”。教练只需要指挥一句：”使用下底传中“就可以让队员知道该怎么做

## 为什么要学习设计模式

很多人在了解了设计模式之后，可能会觉得设计模式只是一些理论知识，在开发中不会有太大的应用

在日常需求开发中，我们更多的是按照需求进行代码的编写，从而达到预期的需求效果，似乎确实没有很明显的去特别应用到设计模式

但就像小说家很少从头开始设计剧情，足球教练很少从头开始发明战术，他们总是沿袭一些已经存在的模式。就像教练看到对方后卫速度慢，中后卫身高矮时，自然想到“下底传中”这种模式

软件设计亦是如此，这些模式是经过大量实际项目验证的优秀解决方案，熟悉这些的开发人员，在某些场景下便可以自然的条件反射想到“这个需求可以用 XXX 设计模式来完成”，也就是**在合适的场合，很快找到合适的方案**

例如：

- 我们看到系统中存在大量相似对象，这些对象可能带来较大的内存负担而需要做优化时，很容易想到利用”享元模式“来优化代码

- 系统中原开发人员设计的某个接口结构已经不符合现在的需求，但又不希望去改动，因为系统中可能有非常多的代码用到了它。这时熟悉的人就可以利用“适配器模式”来解决问题

其实我们在日常开发中，可能也有用到设计模式，只是我们不知道这是一种设计模式。当遇到一个问题时，这个问题似曾相识，或者出现的频率很高，或者很快联想到这个需求似乎可以用自己曾经的某次方案来完成，而这个问题的方案或许就是什么设计模式。如果熟悉设计模式，再又一次遇到这个问题时，想到“这好像可以用 XXX 设计模式来解决”，可能比“这以前什么时候好像在哪做过类似的”更为的清晰可靠

## 设计模式的适用性

使用设计模式，是为了**在合适的场合，找到合适的方案**

这意味着并不是任何场景下，我们都要强行去使用某种设计模式来实现需求。这就好比篮球员在球框下无人防守，只需要投篮即可，难道还需要特意使用某种战术，先传给谁再进行什么操作再投球吗？显示是不必要的，更重要的是**场景下的适用性，在合适的地方，用合适的设计模式**

从某些角度看，设计模式确实可能带来代码量的增加，或许会将逻辑封装的更为复杂。但是软件开发的成本并非全在开发阶段，设计模式是让人写出**可复用、可维护性高**的程序

## 设计模式的核心思想

设计模式的核心思想在于**封装变化**

**找出程序中变化的地方，并将变化封装起来，将变与不变分离，确保变化的部分灵活、不变的部分稳定**

一个程序的设计总是可以分为**可变**的部分与**不可变**的部分，当我们找出可变的部分，并把它们封装起来，剩下的就是不变和稳定的部分了，这些不变和稳定的部分就非常容易复用

需求是不断在变更的，为了时刻应对新的需求，**封装变化**可以让我们编写出更**健壮**的代码，经得起变化的考验，而设计模式，就是帮助我们写出这样的代码

## 设计模式的分类

**GOF** 把这种“模式”观点应用于面向对象的软件设计中，总结了 23 种设计模式，录入《设计模式：可复用面向对象软件的基础》一书

23 种设计模式按照**创建型、行为型、结构型**划分：


![Alt text](./imgs/01-01.png)

无论是哪一种类型，这些具体的设计模式都是在用自己的方式去**封装不同类型的变化**：

- 创建型模式封装了创建对象过程的变化，将创建对象的过程抽离

- 结构型模式封装的是对象之间组合方式的变化

- 行为型模式将对象千变万化的行为进行抽离

封装变化，封装了软件中不稳定的因素，为后续的拓展提供了可能性

## 设计原则

每种设计模式，都是为了让代码迎合其中一个或多个原则而出现的

设计原则是设计模式的指导理论，帮助避免不良的软件设计，主要有 6 个原则：

- 单一职责原则（Single Responsibility Principle）

- 开放封闭原则（Opened Closed Principle）

- 里式替换原则（Liskov Substitution Principle）

- 迪米特法则（Law of Demeter）

- 接口隔离原则（Interface Segregation Principle）

- 依赖反转原则（Dependency Inversion Principle）

统称 **SOLID**（2 个 L 算 1 个）

这里挑选适合 JavaScript 开发的设计原则说明

### 单一职责原则

单一职责原则：**对一个类而言，应该仅有一个引起它变化的原因**。在 JavaScript 中，类应用的场景不如其他语言那么广泛，更多运用到对象或方法级别

单一职责原则的职责被定义为“引起变化的原因”，如果我们一个方法里同时做了 2 件事，例如一个方法里既设置图片，又负责 loading 图加载，那这个方法就有 2 个职责。一个方法承担了过多的职责，那么在需求变迁中，需要改写这个方法的可能性就越大

此时，这个方法会是一个**不稳定**方法，特别在多个职责**耦合**在一起，一个职责的变化可能会影响到其他职责的实现，造成破坏性的结果

因此，单一职责原则体现为：**一个对象（方法）只做一件事**

#### 单一职责原则在设计模式中的体现

- 代理模式：如预加载图片的场景，把添加 img 标签的职责、预加载图片的职责分开放到 2 个对象中，2 个对象各自都只有一个被修改的动机，在它们发生改变时，也不会影响到另外的对象

- 迭代器模式：如往页面添加 div 的场景，把迭代聚合对象的职责、渲染添加 div 的职责分离开

- 单例模式：创建悬浮窗的场景，把管理单例的职责、创建悬浮窗的职责分别封装在 2 个方法里，使它们独立变化互不影响

- 装饰器模式：为对象动态添加职责，这是分离职责的方式。如一开始方法的职责是打开悬浮框，动态添加新的打印职责

#### 何时应该分离职责

**并不是所有的职责都应该一一分离**

一方面，如果随着需求变化，有 2 个职责总是同时变化，就不必分离它们。如 ajax 请求，创建 xhr 对象和发送 xhr 请求几乎总是在一起的，那么创建 xhr 的职责、发送 xhr 请求的职责就没有必要分开

另一方面，职责的变化轴线仅当它们确定会发生变化才具有意义，即使 2 个职责被耦合在一起，但是还没有发改变的征兆，或许也不一定要主动分离它们，在代码需要重构时再分离也不迟

#### 单一职责原则的优缺点

优点：

- 降低单个类、对象、方法复杂度

- 利于复用

- 利用单元测试

- 解耦，一个职责变更不影响其他职责

缺点：

- 增加编写代码的复杂度

- 增大对象之间相互联系的难度

### 迪米特法则

迪米特法则又叫**最少知识原则**：**一个软件实体（对象、系统、类、模块、函数、变量等）应当尽可能少的与其他实体发生相互作用**

如果对象之间产生错综复杂的联系，修改了其中一个对象，很可能影响到它相互应用的其他对象

最少知识原则要求我们在设计程序时，减少对象之间的交互，如果 2 个对象之间不必彼此直接通信，那么这 2 个对象就不要发生直接的相互联系。常见的做法是引入第三者对象，来承担这些对象之间的通讯作用，这样在一个对象改变时，就不需要动到其他对象

#### 迪米特法则在设计模式中的体现

- 中介者模式：如购买足球彩票，上千万的人一起计算赔率和输赢是不可能，这时就需要博彩公司作为中介，每个人都只和博彩公司发生关联即可。这样通过添加一个中介者对象，让所有相关对象都通过中介者对象来通信，而不是相互引用

#### 迪米特法则在封装中的体现

- 封装对象时，可以将内部数据或实现细节隐藏起来，只暴露必要的接口 API 供外界访问。当一个对象必须引用另一个对象时，可以让对象暴露一个接口，让对象之间联系限制在最小范围

- 变量的可见性限制在一个尽可能小的范围，这个变量对其他不相关模块的影响就越小，变量被改写和发生冲突的机会也越小，这也是最少知识原则的体现。例如要编写一个缓存效果的计算乘积的函数，把 cache 对象放在闭包内，显然比放在全局作用域更为合适：

``````````
const mult = (function(){ 
    const cache = {}; 
    return function(){ 
        const args = Array.prototype.join.call(arguments, ','); 
        if (cache[args]){ 
            return cache[args]; 
        } 
        let a = 1; 
        for (let i = 0, l = arguments.length; i < l; i++){ 
            a = a * arguments[i]; 
        } 
        return cache[args] = a; 
    }
})();
``````````
### 开放封闭原则

开放封闭原则是最重要的一条原则：**软件实体（类、模块、函数）等应该对外扩展开放，对内修改关闭**。其他的设计原则，也都是为了让程序更遵守开放封闭原则而出现的

很多时候，一个程序具有良好的设计，往往说明它是符合开放封闭原则的

#### 如何理解开放封闭原则

首先要知道，为什么要开放扩展，关闭修改

开放封闭原则的思想在于：**当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码**

假设一个大型项目接到了新需求，在 window.onload 函数中打印页面中所有节点的数量，于是我们打开编辑器找到了代码中 window.onload 的位置，在函数内添加了代码：

    window.onload = function() {
        ...
        console.log( document.getElementsByTagName('*').length );
        ...
    }

然而其实这种改动代码是一种危险行为，如果目前的 window.onload 是个几百上千行的巨型函数，里面密布着各种交叉的业务逻辑，而我们的需求不仅仅如上打印节点这么简单，很有可能出现：改好一个 BUG，引发新的 BUG 的副作用

这时我们改变方式，不去改动源码，而是扩展新功能：

    Function.prototype.after = function(afterfn){ 
        const __self = this; 
        return function(){ 
            const ret = __self.apply(this, arguments); 
            afterfn.apply(this, arguments); 
            return ret; 
        } 
    }; 
    window.onload = (window.onload || function(){}).after(function(){ 
        console.log(document.getElementsByTagName('*').length); 
    });

利用动态装饰函数的方式，我们完全不用理会从前 window.onload 内部的实现，新增的代码和源代码互相分离

上面的例子，我们用到了 2 种方式：

- 修改源代码

- 扩展新增新代码

哪一种代码更为健壮，不言而喻

除了这个例子，生活中也有体现开放封闭原则的故事：

    有一家生产肥皂的大企业，从欧洲花巨资引入了一条生产线。这条生产线可以自动完成从原材料加工到包装成箱的整个流程，但美中不足的是，生产出来的肥皂有一定的空盒几率。于是老板又从欧洲找来一支专家团队，花费数百万元改造这一生产线，终于解决了生产出空盒肥皂的问题。

    另一家企业也引入了这条生产线，他们同样遇到了空盒肥皂的问题。但他们的解决办法很简单：用一个大风扇在生产线旁边吹，空盒肥皂就会被吹走。

这个故事也可以看出，相比修改源代码，如果通过增加几行代码就能解决问题，显然是更为的简单而优雅，并且增加代码并不会影响原系统的稳定

#### 违背开放封闭原则的常见示例

过多的条件分支语句是造成违背开放封闭原则的常见原因，不论是 if else 还是 swich

例如动物发出叫声的例子：

    const makeSound = function(animal) {
        if(animal instanceof Duck) {
            console.log('嘎嘎嘎');
        } else if(animal instanceof Chicken) {
            console.log('咯咯咯');
        }
    }

    class Duck {}
    class Chicken {}

    makeSound(new Duck());
    makeSound(new Chicken());

当增加了狗后，必须去修改 makeSound 的代码：

    const makeSound = function(animal) {
        if(animal instanceof Duck) {
            console.log('嘎嘎嘎');
        } else if(animal instanceof Chicken) {
            console.log('咯咯咯');
        } else if(animal instanceof Dog) {
            console.log('汪汪汪');
        }
    }

    class Dog {}
    makeSound(new Dog());

这是违背开放封闭原则的，每次增加新的动物，都要去改动 makeSound 的源代码

#### 遵守开放封闭原则的关键

为了做好开放封闭原则，最主要的就是**找到程序中发生变化的地方，封装变化**

就上面的例子而言，**变的是动物的叫声，不变的是叫这个动作**。于是动物怎么叫，可以从 makeSound 中分离出来：

    const makeSound = function(animal) {
        animal.sound();
    }

    class Duck {
        sound() {
            console.log('嘎嘎嘎');
        }
    }
    class Chicken {
        sound() {
            console.log('咯咯咯');
        }
    }

    makeSound(new Duck());
    makeSound(new Chicken());

这样当新的动物加入时，不需要再去改 makeSound 的源码，做到了对内关闭修改，对外可扩展：

    class Dog {
        sound() {
            console.log('汪汪汪');
        }
    }

    makeSound(new Dog());

#### 遵守开放封闭原则的策略

有很多策略可以帮助我们编写出遵守开放封闭原则的代码：

- 放置 hook 挂钩：在程序可能发生变化的地方放置一个挂钩，例如：前端常用的框架 Vue、React 提供的生命周期就相当于一个挂钩，供我们做各式各样的操作。还有模板方法模式在一些个性化的子类中，也就是通过在父类某个容易变化的位置放置倒钩来应对变化

- 回调函数：回调函数也是一种特殊的挂钩，我们将容易发生变化的逻辑封装在回调函数中，把回调作为参数传入一个稳定封闭的函数中，当回调被执行时，程序就可以根据回调函数不同的返回结果，呈现不同的效果。例如：ajax 请求成功失败结果的回调函数（请求用户信息的过程是不变的，获取信息后要做的事情是可变的）、数组遍历方法如 map 方法的回调（把数组里每一项映射为另一个数组的行为是不变的，如何映射的规则是可变的）

#### 开放封闭原则在封装中的体现

几乎所有的设计模式都是遵守开放封闭原则的，我们见到的好设计，通常都经得起开放封闭原则的考验

下面举几个例子：

- 装饰者模式：如开头 window.onload 的示例，对 window.onload 源码修改关闭，开放动态扩展功能

- 观察者模式：利用发布-订阅的关系降低多个对象之间的依赖关系，一个对象不再显示调用另一个对象的某个接口，而是让发布者去通知订阅者。当有新订阅者出现时，发布者的代码不需要进行修改

- 模板方法模式：模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以这部分逻辑抽离于父类的模板方法中，而子类的方法具体实现是可变的，于是把这部分变化逻辑封装在子类中。通过增加新的子类来增加新功能，不需要改动父类及其他子类，如何开放封闭原则

- 策略模式：将各种算法都封装在单独的策略类，这些策略类可以被交换使用，策略是可变的，使用策略的客户代码是不变的，当有新的算法时，只需要扩展新增策略类，不需要修改之前的代码

- 代理模式：如预加载图片，现在有一个给图片设置 src 的对象 myImage，当新的需求要增加图片预加载功能时，除了直接改动 myImage 源码，更好的做法是提供代理对象 proxyMyImage，代理负责处理预加载，在图片预加载完成后再将请求转交给原来的 myImage，而 myImage 不需要做任何改动

- 职责链模式：如订单拆分为了 500 元订单、200元订单、普通订单这 3 个函数，通过职责链连接在一起，客户的请求会在这条链里依次传递：

``````````````
const order500yuan = new Chain(function(orderType, pay, stock){ 
    ...
}); 
const order200yuan = new Chain(function(orderType, pay, stock){ 
    ...
}); 
const orderNormal = new Chain(function(orderType, pay, stock){ 
    ...
}); 
order500yuan.setNextSuccessor(order200yuan).setNextSuccessor(orderNormal); 
order500yuan.passRequest(1, true, 10); // 500 元定金预购，得到 100 优惠券
``````````````

当增加新的订单时，只需要扩展新节点，不需要修改原来的代码

#### 开放封闭原则的相对性

如上职责链模式中，当我们新增一个 100 元订单的函数节点时，会做如下操作：

    const order100yuan = new Chain(function(orderType, pay, stock){ 
        ...
    }); 

    order500yuan.setNextSuccessor(order200yuan).setNextSuccessor(order100yuan).setNextSuccessor(orderNormal); 

开放封闭原则的思想是扩展代码，不修改源代码，而这里我们可能会有疑问：这依旧修改了链条的源代码，在中间多改了一个 setNextSuccessor(order100yuan)

实际上，要做到完全封闭几乎是不可能的，总是存在一些无法对其封闭的变化，所以我们要做的，只是尽量做到：

- 挑选出最容易变化的地方进行封装

- 在不可避免修改时，尽量做到修改的是相对容易的地方

就如上订单示例可见，与其编写一个巨大的订单函数，里面包含了各种逻辑，各种 if else，导致每次需求新增都要修改该订单源代码，不如新增节点，从修改整个函数缩小到修改链条节点来的清晰简单