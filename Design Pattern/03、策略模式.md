## 策略模式

在现实中，很多时候有多种途径达到同一个目的地。

例如要去某个地方旅游，可以根据情况选择出现的路线：

- 如果没有时间但是不在乎钱，可以选择坐飞机

- 如果没有钱，可以选择坐大巴或者火车

- 如果再穷一点，可以选择骑自行车

在程序设计中，也常常可以遇到类似的情况，要实现某一功能有多种方案可以选择

如一个压缩文件的程序：

- 选择 zip 算法

- 选择 gzip 算法

这些算法灵活多样，可以随意相互替换，这种解决方案就是**策略模式**

策略模式：**定义一系列算法（方案），把它们一个个封装起来，并且使它们可以相互替换**

### 策略模式计算奖金

很多公司年终奖是根据员工工资基数、年底绩效来发放的：

- 绩效 S，年终 4 倍工资

- 绩效 A，年终 3 倍工资

- 绩效 B，年终 2 倍工资

假设财务部要求我们提供代码，计算员工的年终奖

1. 最初代码实现
`````````````
const calculateBonus = function(performanceLevel, salary) {
    if (performanceLevel === 'S') {
        return salary * 4;
    }
    if (performanceLevel === 'A') {
        return salary * 3;
    }
    if (performanceLevel === 'B') {
        return salary * 2;
    }
};

calculateBonus('B', 3000);
calculateBonus('S', 4000);
`````````````

但是这样的代码存在显而易见的缺点：

- calculateBonus 函数内代码庞大，包含很多 if 分支

- calculateBonus 缺乏弹性，如果要增加新的绩效 C，或把绩效 S 系数改为 5，必须深入 calculateBonus 内部实现，违反开放封闭原则

- 算法复用性差，如果在其他地方要重用这些计算奖金的算法，只能复制粘贴

2. 使用组合函数重构代码：
`````````````
const performanceS = function(salary) {
    return salary * 4;
};
const performanceA = function(salary) {
    return salary * 3;
};
const performanceB = function(salary) {
    return salary * 2;
};
const calculateBonus = function(performanceLevel, salary) {
    if (performanceLevel === 'S') {
        return performanceS(salary);
    }
    if (performanceLevel === 'A') {
        return performanceA(salary);
    }
    if (performanceLevel === 'B') {
        return performanceB(salary);
    }
};

calculateBonus('B', 3000);
calculateBonus('S', 4000);
`````````````

程序得到了一定的改善，但是依旧没有解决：**calculateBonus 庞大、缺乏弹性的问题**

3. 使用策略模式重构代码

策略模式的定义是：**定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换**

策略模式的目的是将**算法的使用**和**算法的实现**分离开

这个例子就非常适合策略模式，奖金的计算就相当于一个个算法。算法的使用是**不变**的，都是根据某个算法取得计算后的奖金数额，而算法的实现是**变化**的，每种绩效对应着不同的计算规则

    const strategies = {
        "S": function(salary) {
            return salary * 4;
        },
        "A": function(salary) {
            return salary * 3;
        },
        "B": function(salary) {
            return salary * 2;
        }
    };

    const calculateBonus = function(level, salary) {
        return strategies[level](salary);
    };

    calculateBonus('B', 3000);
    calculateBonus('S', 4000);

可以看到，这样的代码实现解决了前面的问题：

- calculateBonus 庞大，现在 calculateBonus 只用来去调用某个策略算法，非常简洁

- calculateBonus 弹性，现在有新的绩效 C 加入时，只需要为策略对象 strategies 添加代码，不需要动到 calculateBonus 代码

- 复用性，现在程序其他地方需要用到计算奖金的算法，只用调用 strategies 即可

### 策略模式实现动画

如果有学过运动框架，就接触过策略模式，其实运动框架的实现方案，就是策略模式

- 动画执行的逻辑是**不变**的

- 动画的实现算法是**可变**的

所以我们可以用策略模式，将动画的实现算法分离开，单独放在策略对象中，让动画执行逻辑去调用：

    const raf = requestAnimationFrame || function(fn) {
        return setTimeout(fn, 1000/60);
    }
    /**
     * 运动框架（时间版）
     * @param ele: DOM元素
     * @param attr: 动画的属性，如'width'
     * @param targetVal: 运动最终目标，如800
     * @param time: 整个动画过程总时长，如5000
     * @param theme: 运动趋势曲线
     */
    function animateTheme(ele, attr, targetVal, time, theme) {
        const cssObj = ele.currentStyle || getComputedStyle(ele);
        let startVal = parseFloat(cssObj[attr]) || 0;

        // 初始时间
        const startDate = new Date();
        function Move() {
            const currentDate = new Date();
            const isEnd = currentDate - startDate >= time;

            const Sx = typeof theme === 'string'
                ? Tween[theme](currentDate - startDate, startVal, targetVal - startVal, time)
                : theme(currentDate - startDate, startVal, targetVal - startVal, time);
            ele.style[attr] = `${Sx}px`;
            !isEnd && raf(Move);
        }
        raf(Move);
    }

    /**
     * @param t: current time
     * @param b: beginning value
     * @param c: change in value
     * @param d: duration
     */
    const Tween = {
        linear: function (t, b, c, d){  //匀速
            return c*t/d + b;   //  t/d = prop;
        },
        easeIn: function(t, b, c, d){  //加速曲线
            return c*(t/=d)*t + b;
        },
        easeOut: function(t, b, c, d){  //减速曲线
            return -c *(t/=d)*(t-2) + b;
        },
        ...
    };

### 更广义的“算法”

策略模式指的是定义一系列算法，并把它们封装起来

我们介绍的计算奖金和动画实现的例子都封装了一些算法

然而在实际开发中，我们通常会把算法的含义扩展开，不单单封装的是算法，也可以封装一系列“业务规则”，只要这些业务规则指向的目标一致，并且可以被替换使用，就可以用策略模式来封装它们

下面将介绍用策略模式来校验用户是否输入合法，而合法规则，即是我们说的业务规则

### 策略模式实现表单验证

在 Web 项目中，注册、登录、修改用户信息等功能的实现都离不开提交表单

在用户输入数据交给后台前，常常要做一些校验工作，如是否填了用户名、密码长度是否符合等

假如我们正在编写一个注册页面，有如下几条校验规则：

- 用户名不能为空

- 密码长度不能少于 6 位

- 手机号码必须符合格式

1. 最初的代码实现
`````````````
<form action="http:// xxx.com/register" id="registerForm" method="post"> 
    请输入用户名：<input type="text" name="userName"/ > 
    请输入密码：<input type="text" name="password"/ >
    请输入手机号码：<input type="text" name="phoneNumber"/ > 
    <button>提交</button> 
</form>

var registerForm = document.getElementById('registerForm');

registerForm.onsubmit = function() {
    if (registerForm.userName.value === '') {
        alert('用户名不能为空');
        return false;
    }
    if (registerForm.password.value.length < 6) {
        alert('密码长度不能少于 6 位');
        return false;
    }
    if (!/(^1[3|5|8][0-9]{9}$)/.test(registerForm.phoneNumber.value)) {
        alert('手机号码格式不正确');
        return false;
    }
}
`````````````

然而这样的代码与奖金示例一开始是一样的：

- registerForm.onsubmit 函数庞大，包含很多 if 分支

- registerForm.onsubmit 缺乏弹性，如果要增加一个新规则，必须深入 registerForm.onsubmit 内部做调整，违反开放封闭原则

- 复用性差，别的地方的表单也要用这些校验规则，只能复制粘贴

2. 使用策略模式实现表单校验

我们用策略模式来重构代码，很明显，变的是校验规则，我们可以把校验规则都封装在一个策略对象中：

    const strategies = {
        isNonEmpty: function (value, errorMsg) { // 不为空
            if (value === '') return errorMsg;
        },
        minLength: function (value, length, errorMsg) { // 限制最小长度
            if (value.length < length) return errorMsg;
        },
        isMobile: function (value, errorMsg) { // 手机号码格式
            if (!/(^1[3|5|8][0-9]{9}$)/.test(value)) return errorMsg;
        }
    };

接着在 registerForm.onsubmit 使用策略对象：

    registerForm.onsubmit = function() {
        let errorMsg = 
            strategies.isNonEmpty(registerForm.userName.value, '用户名不能为空')
        || strategies.minLength(registerForm.password.value, 6, '密码长度不能少于 6 位')
        || strategies.isMobile(registerForm.phoneNumber.value, '手机号码格式不正确');
        if (errorMsg) {
            alert(errorMsg);
            return false;
        }
    }

可以看到，现在表单校验的重构已经优化了很多了

。