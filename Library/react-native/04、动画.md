## Animated

RN 提供了 Animated 做动画

Animated 仅封装了 6 个可以动画化的组件:

- View

- Text

- Image

- ScrollView

- FlatList

- SectionList

也可以使用 Animated.createAnimatedComponent 封装自己的组件

> 动画执行不会触发组件 render

### 基本使用

Animated 提供了一些方法创建动画类型:

- timing: 使用缓动功能随时间推移动画值

- decay: 以初始速度开始并逐渐减速至停止

- spring: 提供一个简单的弹簧物理模型

```tsx
const App = () => {
    // new Animated.Value 返回的值，会自动在 start 时变化，通常 hook 放 ref，Class Component 放在 this.xxx，不需要放在 state
    const translateAnim = useRef(new Animated.Value(0)).current;
    const opacityAnim = useRef(new Animated.Value(0)).current;

    useEffect(() => {
        Animated.timing(
            // 随时间变化而执行动画
            translateAnim, // 动画中的变量值
            {
                toValue: 10, // 透明度最终变为1，即完全不透明
                duration: 1000, // 让动画持续一段时间
                delay: 1000,
                easing: Easing.back(), // easing 曲线
                useNativeDriver: true,
            },
        ).start();

        Animated.timing(
            // 随时间变化而执行动画
            opacityAnim, // 动画中的变量值
            {
                toValue: 1, // 透明度最终变为1，即完全不透明
                duration: 1000, // 让动画持续一段时间
                delay: 1000,
                easing: Easing.back(),
                useNativeDriver: true,
            },
        ).start();
    }, [translateAnim, opacityAnim]);

    return (
        <Animated.View // 使用专门的可动画化的 View 组件
            style={{
                transform: [
                    {
                        translateY: translateAnim,
                    },
                ],
                opacity: opacityAnim,
            }}>
            <Text>啊啊啊啊啊啊啊啊啊????</Text>
        </Animated.View>
    )
}
```

### 顺序执行

Animated.sequence 接收一个动画组，可以让动画按顺序执行

如果有一个动画被停止或中断，组内所有动画都会停止

下面让元素顺序执行动画:

- 透明度 0 - 1

- Y 轴偏移 0 - 100

```tsx
const App = () => {
    const opacityAnim = useRef(new Animated.Value(0)).current;
    const translateYAnim = useRef(new Animated.Value(0)).current;

    useEffect(() => {
        Animated.sequence([
            Animated.timing(opacityAnim, {
                toValue: 1,
                duration: 1000,
                useNativeDriver: true,
            }),
            Animated.timing(translateYAnim, {
                toValue: 100,
                duration: 1000,
                useNativeDriver: true,
            }),
        ]).start();
    }, [opacityAnim, translateYAnim]);

    return (
        <View>
            <Animated.Text
                style={{
                    opacity: opacityAnim,
                    transform: [
                        {
                            translateY: translateYAnim,
                        },
                    ],
                }}>
                动画元素
            </Animated.Text>
        </View>
    );
}
```

### 并行执行

Animated.parallel 可以让动画组并行执行

同 sequence 有一个动画被停止或中断，组内所有动画都会停止

可以配置 stopTogether: false，禁止自动停止

### 合成动画值

可以使用加乘除以及取余等运算来把两个动画值合成为一个新的动画值

- Animated.add: 加

- Animated.divide: 除

- Animated.multiply: 乘

- Animated.modulo: 取模（余数）

```tsx
const App: React.FC = () => {
    const translateYAnim = useRef(new Animated.Value(0)).current;

    useEffect(() => {
        Animated.timing(translateYAnim, {
            toValue: 200,
            useNativeDriver: true,
        }).start();
    }, [translateYAnim]);
    return (
        <View>
            <Animated.Text
                style={{
                    transform: [
                        {
                            translateY: translateYAnim,
                        },
                    ],
                }}>
                demo1
            </Animated.Text>
            <Animated.Text
                style={{
                    transform: [
                        {
                            translateY: Animated.multiply(translateYAnim, 2), // 2倍，即 0 - 400
                        },
                    ],
                }}>
                demo2
            </Animated.Text>
        </View>
    );
};
```

### 插值

value.interpolate 即通过插值来计算，将输入范围映射到输出范围

例如要考虑动画，当透明的从 0 - 1 时，translateY 从 0 - 100，

```tsx
value.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 100]
});
```

```tsx
const App: React.FC = () => {
    const opacityAnim = useRef(new Animated.Value(0)).current;

    useEffect(() => {
        Animated.timing(opacityAnim, {
            toValue: 1,
            useNativeDriver: true,
        }).start();
    }, [opacityAnim]);

    return (
        <View>
            <Animated.Text
                style={{
                    opacity: opacityAnim,
                    transform: [
                        {
                            translateY: opacityAnim.interpolate({
                                inputRange: [0, 1],
                                outputRange: [0, 100],
                            }),
                        },
                    ],
                }}>
                demo
            </Animated.Text>
        </View>
    );
};
```

interpolate 还支持多个区间段落:

```tsx
value.interpolate({
    inputRange: [-300, -100, 0, 100, 101],
    outputRange: [300, 0, 1, 0, 0]
});
```

还支持字符串的映射:

```tsx
value.interpolate({
    inputRange: [0, 360],
    outputRange: ['0deg', '360deg']
});
```

### 跟踪动态值

toValue 除了设置定值，还可以设置一个动态值，达到跟踪效果

```tsx
const App: React.FC = () => {
    const translateYAnim1 = useRef(new Animated.Value(0)).current;
    const translateYAnim2 = useRef(new Animated.Value(0)).current;

    useEffect(() => {
        Animated.timing(translateYAnim1, {
            toValue: 100,
            duration: 1000,
            useNativeDriver: true,
        }).start();

        Animated.timing(translateYAnim2, {
            // 根据 translateYAnim1，在它的基础上 + 10
            toValue: Animated.add(translateYAnim1, 10),
            useNativeDriver: true,
            duration: 0, // 设为 0 则实时跟踪，否则似乎会在前一个完成后才执行动画
        }).start();
    }, [translateYAnim1, translateYAnim2]);
    return (
        <View>
            <Animated.Text
                style={{
                    transform: [
                        {
                            translateY: translateYAnim1,
                        },
                    ],
                }}>
                demo
            </Animated.Text>
            <Animated.Text
                style={{
                    transform: [
                        {
                            translateY: translateYAnim2,
                        },
                    ],
                }}>
                demo2
            </Animated.Text>
        </View>
    );
};
```