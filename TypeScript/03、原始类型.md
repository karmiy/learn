## 原始类型

TypeScript 的原始类型包括：

- void

- undefined

- null

- string

- number

- boolean

- symbol

- bigint

> 注： TypeScript 的原始类型都是小写字母开头，而不是类似 String、Number、Boolean，后者是 JavaScript 的构造函数

### boolean

    const isLoading: boolean = false;

### number

    const n1: number = 6;
    const n2: number = 0xf00d;
    const n3: number = 0b1010;
    const n4: number = 0o744;

### string

    const str = 'Karmiy';

### void

    // 通常当函数没有返回值使用
    function build(): void {
        console.log('123');
    }
    // 只有 undefined 可以赋值给void
    const v1: void = undefined;

### null 与 undefined

    const n: null = null;
    const u: undefined = undefined;
    // 默认情况下 null 与 undefined 是所有类型的子类型
    // 即可以把它们赋值给 number
    // 但是项目开发中一般开启 --strictNullChecks
    // 即 null 与 undefined 只能赋值给 any 与它们自己(特例 undefined 可以给 void)
    // 即 const nu: number = null; 默认是可以的，strictNullChecks 下不行

### symbol

使用 symbol，需要在 tsconfig.json 里添加 es6 编译辅助库:

    // "lib": ["es6", "dom"]

    const sym: symbol = Symbol('key');

### BigInt

在 TypeScript3.2 版本内置，可以安全地存储和操作大整数

    // 使用 BigInt，需要在 tsconfig.json 里添加 ESNext 编译辅助库:
    // "lib": ["es6", "dom", "ESNext"]

    const bigNumber: bigint = BigInt(Number.MAX_SAFE_INTEGER);

### 小结 

TypeScript 中的原始类型：

1. 布尔类型：boolean

2. 数字类型：number

3. 字符串类型：string

4. 空值：void

5. Null 和 Undefined：null 和 undefined

6. Symbol 类型：symbol

7. BigInt 大数整数类型：bigint


## 其他常见类型

顶级类型：

- any

- unknown

底部类型：

- never

非原始类型(non-primitive type)：

- object

还有常见的数组、元组等

### any

我们可能会想为编译阶段还不清楚类型的变量指定类型

不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查，就可以使用 any 标记这些变量

    let a: any = 4;
    a = '123'; // ok

通常除非不得了，不应该考虑使用 any 类型，any 是多人协作的大忌，可能将 Typescript 变为 AnyScript

### unknown

TypeScript3.0 版本引入的新类型，是 **any** 对应的安全类型

> 与 any 区别：

更加严格，在对 unknown 类型的变量操作前，我们**必须先进行检查**，而 any 类型不需要

    // 以下操作都是可行的
    let any_value: any;

    any_value = true;             // OK
    any_value = 1;                // OK
    any_value = "Hello World";    // OK
    any_value = Symbol("type");   // OK
    any_value = {}                // OK
    any_value = []                // OK

    let unknown_value: unknown;

    unknown_value = true;             // OK
    unknown_value = 1;                // OK
    unknown_value = "Hello World";    // OK
    unknown_value = Symbol("type");   // OK
    unknown_value = {}                // OK
    unknown_value = []                // OK

    // 但当需要操作变量时
    any_value.foo.bar;  // OK
    any_value();        // OK
    new any_value();    // OK
    any_value[0][1];    // OK

    unknown_value.foo.bar;  // ERROR
    unknown_value();        // ERROR
    new unknown_value();    // ERROR
    unknown_value[0][1];    // ERROR

可以看出，unknown 是更为安全的，在它被确定为某个类型前，是不能被进行任何操作的

> 如何操作 unknown 的变量？

那就需要用到后面会涉及的**类型保护**

    function getStrValue(value: unknown): string {
        if(value instanceof Date) {
            return value.toISOString();
        }
        return String(value);
    }
