## 装饰器

装饰器主要作用是给一个已有的方法或类**扩展一些新行为**，而不是直接修改它本身

在 ES2015 加入 class 后，当我们需要在不同的类之间共享或扩展一些方法或行为时，代码会变得错综复杂不优雅，这也就是装饰器被提出的一个很重要的原因

目前 JavaScript 对装饰器推进的较慢，在 JavaScript 中使用我们需要 babel-plugin-transform-decorators-legacy 支持 decorator

在 TypeScript 中，我们需要在 tsconfig.json 中配置 "experimentalDecorators": true 来支持装饰器

> 装饰器的语法是个语法糖，本质上是函数

目前装饰器本质上是个函数，@expression 的形式其实个语法糖，expression 求值后也必须是个函数，它会在运行时被调用，被装饰的声明信息作为参数传入

如同 JavaScript 的 class 其实也只是语法糖：

    class Person{
        say() {
            console.log('hello')
        }
    }

    本质上是：

    function Person() {}
    Object.defineProperty(Person.prototype, 'say', {
        value: function() { console.log('hello'); },
        enumerable: false,
        configurable: true,
        writable: true
    });

### 类装饰器

比如我们可以声明一个函数 addAge 作为装饰器为 class 的属性 age 赋值：

    function addAge(constructor: Function) {
        constructor.prototype.age = 18;
    }

    @addAge
    class Person {
        name!: string;
        age!: number;
        constructor() {
            this.name = 'karmiy';
        }
    }
    const person = new Person();
    console.log(person.age); // 18

这段代码在编译后其实是：

![Alt text](imgs/13-01.png)

可以看到，其实就是将 Person **构造函数传入一个装饰函数中进行加工**

所以我们在 addAge 中接收的参数 constructor 即为 Person 构造函数